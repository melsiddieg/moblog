<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>mofeed.xyz</title>
<link>https://mofeed.xyz/</link>
<atom:link href="https://mofeed.xyz/index.xml" rel="self" type="application/rss+xml"/>
<description>Technology, Data Science, AI, and everything in between</description>
<generator>quarto-1.7.32</generator>
<lastBuildDate>Mon, 08 Dec 2025 08:00:00 GMT</lastBuildDate>
<item>
  <title>The Year of the Linux Desktop Is Finally Here — But Not for Humans!</title>
  <dc:creator>Mohammed Abdallah</dc:creator>
  <link>https://mofeed.xyz/posts/linux-agentic-desktop/</link>
  <description><![CDATA[ 






<p>For decades, the open-source world has asked: <em>“Is this finally the year of the Linux desktop?”</em> For actual humans, the answer always seemed to be “not quite”—until now. The catch? <strong>Linux desktops have finally conquered the world… but as the home turf of AI agents, not people.</strong></p>
<p>Yes, in the age of superagents—digital workers like OpenAI’s Agent Mode, Manus, TARS, and more—the Linux desktop is having its victory lap. It’s just that the new users don’t need a mouse, a coffee, or a standing desk. They’re <em>AI</em>, and they’ve found their perfect desktop home.</p>
<p><img src="https://mofeed.xyz/posts/linux-agentic-desktop/archon-os-datacenter.jpg" class="img-fluid"></p>
<section id="the-linux-paradox-invisible-power-visible-absence" class="level2">
<h2 class="anchored" data-anchor-id="the-linux-paradox-invisible-power-visible-absence">The Linux Paradox: Invisible Power, Visible Absence</h2>
<p>To understand why this is such a plot twist, you need to appreciate the <em>paradox</em> of Linux: it is <strong>everywhere and nowhere</strong>.</p>
<ul>
<li><strong>Linux is the invisible backbone of the internet:</strong> It runs the majority of the world’s servers, powers almost every major website, and forms the core of cloud giants like AWS, Google Cloud, and Azure.</li>
<li><strong>Supercomputing? It’s Linux.</strong> Over 95% of the world’s fastest supercomputers run on Linux.</li>
<li><strong>The Cloud? Linux runs the show.</strong> Most virtual machines spun up in the cloud are Linux. When companies deploy at scale, it’s always Linux under the hood.</li>
<li><strong>Your phone? That’s Linux, too.</strong> Android, the world’s most popular mobile OS, is built on the Linux kernel.</li>
</ul>
<p>But despite dominating everywhere else, Linux has always been the <strong>underdog on the personal desktop</strong>. Windows reigns supreme in homes, schools, and businesses. macOS has its loyal fanbase. For the average computer user, the “Linux desktop” is barely visible—unless you’re a developer, a sysadmin, or an academic.</p>
</section>
<section id="the-dream-deferred-waiting-for-the-year-of-the-linux-desktop" class="level2">
<h2 class="anchored" data-anchor-id="the-dream-deferred-waiting-for-the-year-of-the-linux-desktop">The Dream Deferred: Waiting for the Year of the Linux Desktop</h2>
<p>Ask any Linux enthusiast: <em>The “Year of the Linux Desktop”</em> is practically a meme.</p>
<ul>
<li>For 25+ years, advocates believed that any day now, Linux would become the OS of choice for everyone—more stable, more secure, more customizable.</li>
<li>In reality? Despite huge popularity with developers, hackers, and researchers—and legendary status in universities—Linux never quite broke through with the masses.</li>
<li>Mainstream adoption always seemed just out of reach, blocked by hardware compatibility, proprietary software, gaming, and the inertia of the Windows world.</li>
</ul>
<p>Yet the dream never died. Conferences, blogs, and podcasts would regularly ask: <em>“Is this finally the year?”</em> The answer, year after year, was “not quite.”</p>
</section>
<section id="why-ai-agents-choose-linux-and-why-proprietary-oses-are-left-behind" class="level2">
<h2 class="anchored" data-anchor-id="why-ai-agents-choose-linux-and-why-proprietary-oses-are-left-behind">Why AI Agents Choose Linux (And Why Proprietary OSes Are Left Behind)</h2>
<p>The reason for this shift isn’t just hype, or tradition, or even ideology. It comes down to <strong>fundamental technical and economic advantages</strong>:</p>
<section id="open-source-open-world" class="level3">
<h3 class="anchored" data-anchor-id="open-source-open-world">1. <strong>Open Source, Open World</strong></h3>
<ul>
<li><strong>No licensing fees. No legal headaches.</strong> Linux is free at any scale. Spin up 10,000 desktops for agents in the cloud? Nobody’s sending you a bill.</li>
<li><strong>Hackable by design:</strong> Agents (and their creators) can inspect, modify, or automate any part of the stack, from kernel to GUI. Proprietary OSes simply can’t compete here.</li>
<li><strong>Infinite extensibility:</strong> If a tool or feature doesn’t exist, you can build it—or the agent can.</li>
</ul>
</section>
<section id="cloud-supremacy" class="level3">
<h3 class="anchored" data-anchor-id="cloud-supremacy">2. <strong>Cloud Supremacy</strong></h3>
<ul>
<li><strong>Linux dominates the cloud.</strong> Every major cloud provider (AWS, GCP, Azure) is optimized for Linux VMs, containers, and orchestration.</li>
<li>Need to instantly deploy isolated, secure desktops for thousands of agents? Linux is already the backbone.</li>
<li><strong>No OS is as “cloud native” as Linux.</strong> Licensing for Windows VMs is slow, costly, and restrictive. macOS is barely available outside Apple’s hardware.</li>
</ul>
</section>
<section id="customizability-speed-and-lean-performance" class="level3">
<h3 class="anchored" data-anchor-id="customizability-speed-and-lean-performance">3. <strong>Customizability, Speed, and Lean Performance</strong></h3>
<ul>
<li><strong>Ultra-customizable:</strong> Want a barebones, lightning-fast desktop that boots in seconds and only runs what you need? Linux is built for that.</li>
<li><strong>No bloat:</strong> Agents don’t care for Cortana, Siri, or animated emojis. Linux offers minimalism and raw speed.</li>
<li><strong>Fast to spin, low latency:</strong> The agentic revolution depends on spinning up and tearing down environments in milliseconds. Linux delivers this with tiny disk images, lean memory profiles, and true headless operation.</li>
</ul>
</section>
<section id="proven-automation-scriptability" class="level3">
<h3 class="anchored" data-anchor-id="proven-automation-scriptability">4. <strong>Proven Automation &amp; Scriptability</strong></h3>
<ul>
<li><strong>Automation is native:</strong> Agents can automate GUIs, file systems, networking, and even the kernel itself, using decades-old, battle-tested scripting and API frameworks.</li>
<li><strong>Stable accessibility layers and automation tools:</strong> From DBus to ATK, everything’s accessible, scriptable, and open.</li>
</ul>
</section>
</section>
<section id="the-rise-of-ai-ready-linux-distros-the-agentic-os-revolution" class="level2">
<h2 class="anchored" data-anchor-id="the-rise-of-ai-ready-linux-distros-the-agentic-os-revolution">The Rise of AI-Ready Linux Distros: The Agentic OS Revolution</h2>
<p>The landscape is evolving so quickly that now <strong>specialized Linux distributions are being purpose-built for AI agents themselves</strong>—ushering in a new era of the “Agentic OS”.</p>
<p><img src="https://mofeed.xyz/posts/linux-agentic-desktop/agentic-os-desktop.png" class="img-fluid"></p>
<ul>
<li><p><strong>Archon OS</strong> is a leading example: an ultra-lean, AI-native Linux distribution designed from the ground up for agentic use. Archon OS boots in seconds, offers tightly sandboxed environments, and comes pre-equipped with all the APIs and automation tools that superagents demand—no onboarding, no distractions, no bloat.</p>
<ul>
<li><em>It’s not about user-friendliness; it’s about agent-efficiency.</em></li>
<li>With secure, ephemeral sandboxes, these distros enable agents to safely spawn, destroy, and scale their own workspaces—hundreds or thousands at a time.</li>
</ul></li>
<li><p>Other spins and projects are following: headless Ubuntu, container-native Debian, cloud-tuned agent images, and more.</p></li>
<li><p>These new “Agent OSes” are optimized not for human workflows, but for <strong>machine-to-machine automation and agentic orchestration</strong>.</p></li>
</ul>
<blockquote class="blockquote">
<p><strong>Just as Ubuntu and Mint made Linux friendlier for people, Archon OS and its siblings are making Linux frictionless for AI agents. The Agentic OS genre has officially arrived.</strong></p>
</blockquote>
</section>
<section id="the-rise-of-superagents-manus-tars-and-beyond" class="level2">
<h2 class="anchored" data-anchor-id="the-rise-of-superagents-manus-tars-and-beyond">The Rise of Superagents: Manus, TARS, and Beyond</h2>
<p>2025 isn’t the year of the human Linux desktop. It’s the year of the <strong>agentic Linux desktop</strong>—the cloud-powered sandbox where AI agents thrive.</p>
<section id="who-are-these-new-digital-power-users" class="level3">
<h3 class="anchored" data-anchor-id="who-are-these-new-digital-power-users">Who are these new digital power-users?</h3>
<section id="openai-agent-mode-operator" class="level4">
<h4 class="anchored" data-anchor-id="openai-agent-mode-operator"><strong>OpenAI Agent Mode / Operator</strong></h4>
<p>Runs its own Linux desktop-in-the-cloud, controlling Chrome, LibreOffice, files, and more. Completes multi-step tasks like downloading, editing, and moving documents with no human clicks required.</p>
</section>
<section id="anthropics-claude-with-computer-use" class="level4">
<h4 class="anchored" data-anchor-id="anthropics-claude-with-computer-use"><strong>Anthropic’s Claude with Computer Use</strong></h4>
<p>Uses Linux sandboxes for visual and API-driven automation, with full access to manipulate GUIs and files.</p>
</section>
<section id="manus.im" class="level4">
<h4 class="anchored" data-anchor-id="manus.im"><strong>Manus.im</strong></h4>
<p>An open-source, agentic “operating system” for AI agents. Manus spins up dedicated Linux environments so any LLM can automate apps, run workflows, and interact with real software—at scale and at speed.</p>
</section>
<section id="tars" class="level4">
<h4 class="anchored" data-anchor-id="tars"><strong>TARS</strong></h4>
<p>A generalist superagent inspired by sci-fi, TARS runs in containerized Linux desktops, mastering browsers, spreadsheets, and even legacy apps, all within secure, reproducible Linux VMs.</p>
</section>
<section id="other-players-ecosystem-tools" class="level4">
<h4 class="anchored" data-anchor-id="other-players-ecosystem-tools"><strong>Other Players &amp; Ecosystem Tools</strong></h4>
<ul>
<li><strong>ScreenEnv:</strong> Open-source project building virtual Ubuntu desktops for AI agent testing, safely and at scale.</li>
<li><strong>Linux Foundation Agent Gateway:</strong> Building standards for cross-agent, cross-app Linux integration.</li>
<li><strong>Academic Projects (ComputerRL, SchedCP):</strong> Advancing agentic automation and reinforcement learning inside Linux GUIs and systems.</li>
</ul>
</section>
</section>
</section>
<section id="what-does-this-mean-for-desktop-apps-on-linux" class="level2">
<h2 class="anchored" data-anchor-id="what-does-this-mean-for-desktop-apps-on-linux">What Does This Mean for Desktop Apps on Linux?</h2>
<p>If you make desktop software for Linux, your most active users soon may not be people, but <strong>agents</strong>.</p>
<section id="a-new-kind-of-user" class="level3">
<h3 class="anchored" data-anchor-id="a-new-kind-of-user"><strong>A New Kind of “User”:</strong></h3>
<ul>
<li><strong>Automation is king:</strong> Agents demand robust APIs, headless modes, and stable scripting. If your app can’t be reliably automated, it will be left behind.</li>
<li><strong>Accessibility and stability matter:</strong> UI elements must be predictable and well-exposed. Fragile GUI automation is a dealbreaker.</li>
<li><strong>Security and sandboxing:</strong> Agents need just enough access, never more. Fine-grained permissions and logs are now basic hygiene.</li>
<li><strong>Native support is a must:</strong> Apps with flaky Linux ports will be abandoned for native alternatives, or for open-source clones.</li>
</ul>
</section>
<section id="ux-for-agents-not-humans" class="level3">
<h3 class="anchored" data-anchor-id="ux-for-agents-not-humans"><strong>UX for Agents (Not Humans):</strong></h3>
<ul>
<li>Apps may expose semantic, task-based APIs (“generate a report from these files”) instead of just GUI-driven interfaces.</li>
<li>Logging, feedback, and “undo” support will be crucial for auditing and safety.</li>
</ul>
</section>
<section id="the-app-developers-dilemma" class="level3">
<h3 class="anchored" data-anchor-id="the-app-developers-dilemma"><strong>The App Developer’s Dilemma:</strong></h3>
<blockquote class="blockquote">
<p>How do you test your app for agents? Start thinking about CI pipelines where your “user” is an AI agent running inside a Linux sandbox!</p>
</blockquote>
</section>
</section>
<section id="the-surprise-boon-for-linux-apps-libreoffice-gimp-inkscape-beyond" class="level2">
<h2 class="anchored" data-anchor-id="the-surprise-boon-for-linux-apps-libreoffice-gimp-inkscape-beyond">The Surprise Boon for Linux Apps: LibreOffice, GIMP, Inkscape &amp; Beyond</h2>
<p>Ironically, the new era of agentic Linux desktops could be the best thing that’s ever happened to open source desktop apps.</p>
<p><img src="https://mofeed.xyz/posts/linux-agentic-desktop/ai-agent-user.png" class="img-fluid"></p>
<ul>
<li><p><strong>LibreOffice is now being used by agents as a workhorse for document generation, editing, and automation at unprecedented scale</strong>—not just by humans writing essays, but by superagents assembling reports, forms, and knowledge bases around the clock.</p>
<ul>
<li>Every day, LibreOffice Writer, Calc, and Impress are being driven to their limits, automating tasks faster and at greater volume than most human users ever could.</li>
<li>Agents’ demands are relentless and uncompromising. Even minor bugs, clunky behaviors, or slow performance become immediate bottlenecks at scale—<strong>forcing rapid iteration, bugfixes, and quality improvements.</strong></li>
</ul></li>
<li><p><strong>Other Linux apps, too—like Inkscape, GIMP, and countless writing and workflow tools—are getting a second life.</strong></p>
<ul>
<li>Agents use GIMP and Inkscape for image generation, conversion, and batch-editing; text tools for automated content creation and formatting.</li>
<li>Tools that may have lagged behind their proprietary Windows/macOS counterparts are now being “battle-tested” by AI. The “good enough” bar is rising—agents are discovering edge cases, pushing APIs, and exposing bugs that would otherwise stay hidden.</li>
<li>As agents become power users, open source app developers are gaining new telemetry, feedback, and bug reports at a rate never seen before.</li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p><strong>What does this mean?</strong> The “AI desktop” could spark an <em>unprecedented renaissance</em> for Linux desktop apps. With agents pushing, breaking, and improving these tools at scale, we may finally see LibreOffice, GIMP, Inkscape and other stalwarts close the gap with (or even leapfrog) proprietary software—not for human polish, but for raw reliability, scriptability, and automation.</p>
</blockquote>
</section>
<section id="why-not-windows-or-mac" class="level2">
<h2 class="anchored" data-anchor-id="why-not-windows-or-mac">Why Not Windows or Mac?</h2>
<p><strong>The short version:</strong></p>
<ul>
<li><strong>Windows and macOS are locked-down, expensive, and bloated.</strong></li>
<li>License fees, restrictive virtualization, slow boot times, proprietary protocols, and unpredictable updates all stand in the way of agentic automation.</li>
<li>The cloud isn’t optimized for them, and neither are AI workflows.</li>
</ul>
<p>Agents don’t want branding—they want <em>freedom and speed</em>.</p>
</section>
<section id="the-future-the-decade-of-the-agentic-linux-desktop" class="level2">
<h2 class="anchored" data-anchor-id="the-future-the-decade-of-the-agentic-linux-desktop">The Future: The Decade of the Agentic Linux Desktop</h2>
<p>From 2025 onward, expect:</p>
<ul>
<li><strong>Agent-aware apps:</strong> Major Linux software will ship “agent mode” APIs and automation docs.</li>
<li><strong>Standardized agent protocols:</strong> Open standards (like Model Context Protocol) will make agentic workflows cross-app and cross-platform.</li>
<li><strong>Zero-trust security:</strong> Granular sandboxing and permissioning for all agent activities.</li>
<li><strong>Agent dashboards:</strong> Linux desktops will include visual management tools for agent workflows and activity logs.</li>
<li><strong>A new breed of distros:</strong> AI-ready, agent-optimized Linux OSes like Archon OS will become the “default” for cloud and automation-driven agent infrastructure.</li>
</ul>
</section>
<section id="the-year-of-the-linux-desktop-has-arrived-for-ai" class="level2">
<h2 class="anchored" data-anchor-id="the-year-of-the-linux-desktop-has-arrived-for-ai">The Year of the Linux Desktop Has Arrived… For AI</h2>
<p>So, after decades of waiting, the Linux desktop <em>finally</em> wins—but not in the way anyone predicted. The new power-users are silent, fast, and relentless. They don’t need themes or wallpapers. They need access, speed, and infinite customization. And that’s exactly what Linux delivers.</p>
<p><strong>For humans, the “year of the Linux desktop” is a meme. For AI agents—and for the distros being built just for them—it’s already a reality.</strong></p>


</section>

 ]]></description>
  <category>linux</category>
  <category>ai</category>
  <category>agents</category>
  <category>open-source</category>
  <guid>https://mofeed.xyz/posts/linux-agentic-desktop/</guid>
  <pubDate>Mon, 08 Dec 2025 08:00:00 GMT</pubDate>
  <media:content url="https://mofeed.xyz/posts/linux-agentic-desktop/archon-os-datacenter.jpg" medium="image" type="image/jpeg"/>
</item>
<item>
  <title>Efficient Data wrangling in R</title>
  <dc:creator>Mohammed Abdallah</dc:creator>
  <link>https://mofeed.xyz/posts/efficient-data-r/</link>
  <description><![CDATA[ 






<p><img src="https://mofeed.xyz/posts/efficient-data-r/plot2.png" class="img-fluid" alt="Big Data"></p>
<section id="advanced-techniques-for-efficient-large-data-handling-in-r" class="level1">
<h1>Advanced Techniques for Efficient Large Data Handling in R</h1>
<p>In the era of big data, R users often find themselves grappling with datasets that push the limits of their hardware.</p>
<p>Traditional approaches using packages like tidyverse or data.table can struggle when faced with truly massive datasets. But fear not! A new generation of tools and techniques is emerging, offering R users powerful ways to handle large data efficiently. In this post, we’ll explore some of these advanced techniques, focusing on three key players in the R ecosystem: Arrow, Polars, and DuckDB.</p>
<section id="the-power-of-efficient-file-formats-and-partitioning" class="level2">
<h2 class="anchored" data-anchor-id="the-power-of-efficient-file-formats-and-partitioning">The Power of Efficient File Formats and Partitioning</h2>
<p>Before diving into specific tools, it’s crucial to understand the importance of efficient file formats and data partitioning.</p>
<section id="parquet-the-champion-of-big-data" class="level3">
<h3 class="anchored" data-anchor-id="parquet-the-champion-of-big-data">Parquet: The Champion of Big Data</h3>
<p>Parquet has become the go-to file format for big data analytics, and for good reason. It’s a columnar storage format that offers excellent compression and supports predicate pushdown, allowing for efficient querying of large datasets. When working with big data in R, converting your data to Parquet can lead to significant performance improvements.</p>
</section>
<section id="partitioning-divide-and-conquer" class="level3">
<h3 class="anchored" data-anchor-id="partitioning-divide-and-conquer">Partitioning: Divide and Conquer</h3>
<p>Partitioning is a technique that divides large datasets into smaller, more manageable chunks. This approach enables parallel processing and efficient querying. A common partitioning strategy is to split data by date, creating a directory structure like <code>/year=2023/month=06/data.parquet</code>. This allows you to quickly filter data based on time periods without scanning the entire dataset.</p>
<p>Here’s a quick example of how you can convert a large CSV file to partitioned Parquet using the Arrow package in R:</p>
<pre><code>library(arrow)
library(dplyr)

# Read CSV file
csv_dataset &lt;- open_dataset("large_dataset.csv", format = "csv")

# Define partitioning schema and write to partitioned Parquet
write_dataset(csv_dataset, 
              "partitioned_dataset",
              format = "parquet",
              partitioning = schema(year = int32(), month = int32()))</code></pre>
<p>This code reads a large CSV file and writes it as a partitioned Parquet dataset, organized by year and month.</p>
</section>
</section>
<section id="arrow-the-swiss-army-knife-of-big-data" class="level2">
<h2 class="anchored" data-anchor-id="arrow-the-swiss-army-knife-of-big-data">Arrow: The Swiss Army Knife of Big Data</h2>
<p>Apache Arrow is a cross-language development platform for in-memory data, providing a standardized columnar memory format. The Arrow package in R brings this power to the R ecosystem.</p>
<section id="key-features-of-arrow" class="level3">
<h3 class="anchored" data-anchor-id="key-features-of-arrow">Key Features of Arrow:</h3>
<ol type="1">
<li><p><strong>Memory Mapping</strong>: Allows efficient access to data without loading entire datasets into memory.</p></li>
<li><p><strong>SIMD Operations</strong>: Utilizes CPU’s Single Instruction, Multiple Data capabilities for faster processing.</p></li>
<li><p><strong>Streaming Execution</strong>: Processes data in chunks, reducing memory footprint.</p>
<p>Here’s an example of using Arrow to efficiently query a partitioned Parquet dataset:</p></li>
</ol>
<pre><code>library(arrow)

# Open partitioned dataset
dataset &lt;- open_dataset("partitioned_dataset", format = "parquet")

# Efficient querying with partition and predicate pushdown
result &lt;- dataset %&gt;%
  filter(year == 2023, month == 6) %&gt;%
  select(col1, col2) %&gt;%
  collect()</code></pre>
<p>This query leverages both partition pruning and predicate pushdown, ensuring that only the necessary data is read and processed.</p>
</section>
</section>
<section id="polars-speed-and-efficiency-in-r" class="level2">
<h2 class="anchored" data-anchor-id="polars-speed-and-efficiency-in-r">Polars: Speed and Efficiency in R</h2>
<p>Polars is a lightning-fast DataFrames library implemented in Rust, with bindings available for R. It offers both eager and lazy execution modes, providing flexibility and performance.</p>
<section id="polars-lazy-execution" class="level3">
<h3 class="anchored" data-anchor-id="polars-lazy-execution">Polars Lazy Execution:</h3>
<p>Polars’ lazy execution mode allows for query optimization, potentially leading to significant performance improvements. Here’s an example:</p>
<pre><code>library(polars)

# Create a lazy DataFrame with streaming enabled
lazy_df &lt;- pl$lazy_csv_reader("large_dataset.csv", rechunk = FALSE)

# Define operations
result &lt;- lazy_df$
  select(pl$col("col1"), pl$col("col2"))$
  filter(pl$col("col1") &gt; 100)$
  group_by("col2")$
  agg(pl$col("col1")$mean())$
  collect(streaming = TRUE)</code></pre>
<p>In this example, Polars optimizes the query plan and uses streaming execution to efficiently process the data.</p>
</section>
</section>
<section id="duckdb-sql-power-for-local-data" class="level2">
<h2 class="anchored" data-anchor-id="duckdb-sql-power-for-local-data">DuckDB: SQL Power for Local Data</h2>
<p>DuckDB brings the power of a columnar-oriented SQL database to local, serverless environments. It’s particularly well-suited for analytical queries on large datasets.</p>
<section id="duckdbs-efficiency" class="level3">
<h3 class="anchored" data-anchor-id="duckdbs-efficiency">DuckDB’s Efficiency:</h3>
<p>DuckDB optimizes for the entire memory hierarchy, from CPU cache to disk. It uses techniques like vectorized execution and adaptive algorithms to process data efficiently. Here’s an example of using DuckDB to query a partitioned Parquet dataset:</p>
<pre><code>library(duckdb)
library(dplyr)

con &lt;- dbConnect(duckdb())
result &lt;- tbl(con, "parquet_scan('partitioned_dataset/**/*.parquet', 
                                 hive_partitioning=1)") %&gt;%
  filter(year == 2023, month == 6) %&gt;%
  select(col1, col2) %&gt;%
  collect()

dbDisconnect(con, shutdown = TRUE)</code></pre>
<p>DuckDB automatically detects the partitioning scheme and uses it for efficient data skipping.</p>
</section>
</section>
<section id="the-importance-of-operation-order" class="level2">
<h2 class="anchored" data-anchor-id="the-importance-of-operation-order">The Importance of Operation Order</h2>
<p>When working with large datasets, the order of operations can significantly impact performance, especially in eager evaluation systems. Consider this example using dplyr:</p>
<pre><code># Less efficient
df %&gt;%
  group_by(category) %&gt;%
  filter(value &gt; 100) %&gt;%
  summarise(mean_value = mean(value))

# More efficient
df %&gt;%
  filter(value &gt; 100) %&gt;%
  group_by(category) %&gt;%
  summarise(mean_value = mean(value))</code></pre>
<p>In general, it’s more efficient to filter data before grouping. However, lazy evaluation systems like Polars lazy and DuckDB can often optimize the query plan regardless of the order you specify operations.</p>
</section>
<section id="summary-choosing-the-right-tool" class="level2">
<h2 class="anchored" data-anchor-id="summary-choosing-the-right-tool">Summary: Choosing the Right Tool</h2>
<p>Arrow, Polars, and DuckDB each offer unique strengths for handling large datasets in R:</p>
<ul>
<li><p><strong>Arrow</strong> excels in memory mapping and SIMD operations.</p></li>
<li><p><strong>Polars</strong> shines with its lazy evaluation and query optimization.</p></li>
<li><p><strong>DuckDB</strong> stands out for its adaptive algorithms and SQL engine</p></li>
</ul>
</section>
<section id="takeaways-and-best-practices" class="level2">
<h2 class="anchored" data-anchor-id="takeaways-and-best-practices">Takeaways and Best Practices</h2>
<p>When working with large datasets in R, consider these best practices:</p>
<ol type="1">
<li><p>Use partitioned Parquet for storing large datasets.</p></li>
<li><p>Leverage streaming capabilities to reduce memory footprint.</p></li>
<li><p>Utilize automatic chunking and batch processing when available.</p></li>
<li><p>Choose partitioning schemes that align with common query patterns.</p></li>
<li><p>Benchmark different approaches for your specific use case.</p></li>
<li><p>Pay attention to the order of operations, especially in eager evaluation systems</p></li>
</ol>
<p>By employing these advanced techniques and tools, R users can efficiently handle datasets that were once considered too large for local processing. As the R ecosystem continues to evolve, we can expect even more powerful and efficient data handling capabilities in the future.</p>
<p>Happy data crunching!</p>


</section>
</section>

 ]]></description>
  <category>big data</category>
  <category>R</category>
  <category>polars</category>
  <category>duckdb</category>
  <category>apache arrow</category>
  <guid>https://mofeed.xyz/posts/efficient-data-r/</guid>
  <pubDate>Sat, 05 Apr 2025 07:00:00 GMT</pubDate>
</item>
<item>
  <title>Demo Blog</title>
  <dc:creator>Mohammed Abdallah</dc:creator>
  <link>https://mofeed.xyz/posts/first-blog/</link>
  <description><![CDATA[ 






<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://mofeed.xyz/posts/first-blog/plot.png" class="img-fluid figure-img"></p>
<figcaption>base R plot</figcaption>
</figure>
</div>
<section id="ploting-in-r" class="level2">
<h2 class="anchored" data-anchor-id="ploting-in-r">Ploting in R</h2>
<p>Base R plotting is the original graphics system in R, providing a straightforward and flexible approach to data visualization.</p>
<p>It operates on an “artist’s palette” model, where you start with a blank canvas using high-level functions like <code>plot()</code> to create the initial plot, and then incrementally add elements such as points, lines, and text with low-level functions like <code>points()</code>, <code>lines()</code>, and <code>text()</code> .</p>
<p>This layered approach allows for detailed customization of plots, enabling users to adjust various aspects such as axes, labels, colors, and symbols to suit their specific needs . While base R plotting may require more manual adjustments compared to newer systems like <code>ggplot2</code>, it remains a powerful tool for creating a wide range of static graphics, from simple scatter plots to complex multi-panel figures</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1">x <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span><span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">:</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">50</span></span>
<span id="cb1-2">y <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> x<span class="sc" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">^</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span></span>
<span id="cb1-3"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">plot</span>(x,y,<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">col=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'darkgreen'</span>,<span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">pch=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">20</span>)</span></code></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="https://mofeed.xyz/posts/first-blog/index_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>


</section>

 ]]></description>
  <category>R</category>
  <category>Visualizaion</category>
  <guid>https://mofeed.xyz/posts/first-blog/</guid>
  <pubDate>Tue, 01 Apr 2025 07:00:00 GMT</pubDate>
</item>
</channel>
</rss>
